<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodsFromMahout.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco_ant</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">MethodsFromMahout.java</span></div><h1>MethodsFromMahout.java</h1><pre class="source lang-java linenums">import com.google.common.base.Preconditions;
import java.util.List;
import java.util.Random;
import com.google.common.collect.Lists;

<span class="nc" id="L6">public class MethodsFromMahout {</span>
	
/*
	public static double cosineDistance(double[] p1, double[] p2) {
	    double dotProduct = 0.0;
	    double lengthSquaredp1 = 0.0;
	    double lengthSquaredp2 = 0.0;
	    for (int i = 0; i &lt; p1.length; i++) {
	      lengthSquaredp1 += p1[i] * p1[i];
	      lengthSquaredp2 += p2[i] * p2[i];
	      dotProduct += p1[i] * p2[i];
	    }
	    double denominator = Math.sqrt(lengthSquaredp1) * Math.sqrt(lengthSquaredp2);
	    
	    // correct for floating-point rounding errors
	    if (denominator &lt; dotProduct) {
	      denominator = dotProduct;
	    }
	    
	    // correct for zero-vector corner case
	    if (denominator == 0 &amp;&amp; dotProduct == 0) {
	      return 0;
	    }
	    
	    return 1.0 - dotProduct / denominator;
	  }
*/
	
	 public static double manhattanDistance(double[] p1, double[] p2) {
<span class="nc" id="L35">		    double result = 0.0;</span>
<span class="nc bnc" id="L36" title="All 2 branches missed.">		    for (int i = 0; i &lt; p1.length; i++) {</span>
<span class="nc" id="L37">		      result += Math.abs(p2[i] - p1[i]);</span>
		    }
<span class="nc" id="L39">		    return result;</span>
		  }
	 //this was implemented by me since Mahout implementation relies on oo design
	 public static double chebyshevDistance(double[] p1, double[] p2)
	 {
<span class="nc bnc" id="L44" title="All 2 branches missed.">		 if (p1.length != p2.length) {</span>
<span class="nc" id="L45">		      System.out.println(&quot;Error!&quot;);</span>
<span class="nc" id="L46">		      return -1;</span>
		    }
<span class="nc" id="L48">		 double maxDiff=Math.abs(p1[0]-p2[0]);</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">		 for(int i=1;i&lt;p1.length;i++)</span>

			 {
<span class="nc" id="L52">			 	double diff=Math.abs(p1[i]-p2[i]);</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">			 	if(maxDiff&lt;diff)</span>
			 	{
<span class="nc" id="L55">			 		maxDiff=diff;</span>
			 	}
			
			 }
<span class="nc" id="L59">		 return maxDiff;</span>
	 }
	 
	//this was implemented by me since Mahout implementation relies on oo design
	 /**
	   * Calculates the distance between two vectors.
	   * 
	   * The coefficient (a measure of similarity) is: T(a, b) = a.b / (|a|^2 + |b|^2 - a.b)
	   * 
	   * The distance d(a,b) = 1 - T(a,b)
	   * 
	   * @return 0 for perfect match, &gt; 0 for greater distance
	   */
	 public static double tanimotoDistance(double[] p1, double[] p2)
	 {
<span class="nc" id="L74">		 	double ab=0,aSq=0,bSq=0;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">		 	for(int i=0;i&lt;p1.length;i++)</span>
		 	{
<span class="nc" id="L77">		 		ab+=p1[i]*p2[i];</span>
<span class="nc" id="L78">		 		aSq+=p1[i]*p1[i];</span>
<span class="nc" id="L79">		 		bSq+=p2[i]*p2[i];</span>
		 		
		 	}
<span class="nc" id="L82">		 	double denominator=aSq+bSq-ab;</span>
		    
<span class="nc bnc" id="L84" title="All 2 branches missed.">		    if (denominator &lt; ab) { // correct for fp round-off: distance &gt;= 0</span>
<span class="nc" id="L85">		      denominator = ab;</span>
		    }
<span class="nc bnc" id="L87" title="All 2 branches missed.">		    if (denominator &gt; 0) {</span>
		      // denominator == 0 only when dot(a,a) == dot(b,b) == dot(a,b) == 0
<span class="nc" id="L89">		      return 1.0 - ab / denominator;</span>
		    } else {
<span class="nc" id="L91">		      return 0.0;</span>
		    }
	 }
	 /*
	 public static int binarySearchFromTo(int[] array, int value, int from, int to) {
		    int mid = -1;
		    while (from &lt;= to) {
		      mid = (from + to) &gt;&gt;&gt; 1;
		      if (value &gt; array[mid]) {
		        from = mid + 1;
		      } else if (value == array[mid]) {
		        return mid;
		      } else {
		        to = mid - 1;
		      }
		    }
		    if (mid &lt; 0) {
		      return -1;
		    }
		    return -mid - (value &lt; array[mid] ? 1 : 2);
		  }
		  */
	 
	 public static int sum(int[] values) {
<span class="nc" id="L115">		    int sum = 0;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		    for (int value : values) {</span>
<span class="nc" id="L117">		      sum += value;</span>
		    }
		    
<span class="nc" id="L120">		    return sum;</span>
		  }
		  
	 /**
	   * foreach i : array1[i] += array2[i]
	   */
	  public static int[] add(int[] array1, int[] array2) {
<span class="nc bnc" id="L127" title="All 2 branches missed.">	    Preconditions.checkArgument(array1.length == array2.length, &quot;array1.length != array2.length&quot;);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">	    for (int index = 0; index &lt; array1.length; index++) {</span>
<span class="nc" id="L129">	      array1[index] += array2[index];</span>
	    }
<span class="nc" id="L131">	    return array1;</span>
	  }

	  /**
	   * foreach i : array1[i] -= array2[i]
	   */
/*
	  public static int[] dec(int[] array1, int[] array2) {
	    Preconditions.checkArgument(array1.length == array2.length, &quot;array1.length != array2.length&quot;);
	    for (int index = 0; index &lt; array1.length; index++) {
	      array1[index] -= array2[index];
	    }
	    return array1;
	  }
*/
	  
	  /**
	   * return the index of the maximum of the array, breaking ties randomly
	   * 
	   * @param rng
	   *          used to break ties
	   * @return index of the maximum
	   */
	  /*
	  public static int maxindex(Random rng, int[] values) {
	    int max = 0;
	    List&lt;Integer&gt; maxindices = Lists.newArrayList();
	    
	    for (int index = 0; index &lt; values.length; index++) {
	      if (values[index] &gt; max) {
	        max = values[index];
	        maxindices.clear();
	        maxindices.add(index);
	      } else if (values[index] == max) {
	        maxindices.add(index);
	      }
	    }

	    return maxindices.size() &gt; 1 ? maxindices.get(rng.nextInt(maxindices.size())) : maxindices.get(0);
	  }*/
	
	  /**
	   * Efficiently returns the binomial coefficient, often also referred to as &quot;n over k&quot; or &quot;n choose k&quot;. The binomial
	   * coefficient is defined as &lt;tt&gt;(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )&lt;/tt&gt;. &lt;ul&gt; &lt;li&gt;k&lt;0&lt;tt&gt;: &lt;tt&gt;0&lt;/tt&gt;.
	   * &lt;li&gt;k==0&lt;tt&gt;: &lt;tt&gt;1&lt;/tt&gt;. &lt;li&gt;k==1&lt;tt&gt;: &lt;tt&gt;n&lt;/tt&gt;. &lt;li&gt;else: &lt;tt&gt;(n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k
	   * )&lt;/tt&gt;. &lt;/ul&gt;
	   *
	   * @return the binomial coefficient.
	   */
	  /*
	  public static double binomial(double n, long k) {
	    if (k &lt; 0) {
	      return 0;
	    }
	    if (k == 0) {
	      return 1;
	    }
	    if (k == 1) {
	      return n;
	    }

	    // binomial(n,k) = (n * n-1 * ... * n-k+1 ) / ( 1 * 2 * ... * k )
	    double a = n - k + 1;
	    double b = 1;
	    double binomial = 1;
	    for (long i = k; i-- &gt; 0;) {
	      binomial *= (a++) / (b++);
	    }
	    return binomial;
	  }*/
	  
	  /**
	   * Evaluates the series of Chebyshev polynomials Ti at argument x/2. The series is given by
	   * &lt;pre&gt;
	   *        N-1
	   *         - '
	   *  y  =   &gt;   coef[i] T (x/2)
	   *         -            i
	   *        i=0
	   * &lt;/pre&gt;
	   * Coefficients are stored in reverse order, i.e. the zero order term is last in the array.  Note N is the number of
	   * coefficients, not the order. &lt;p&gt; If coefficients are for the interval a to b, x must have been transformed to x -&gt;
	   * 2(2x - b - a)/(b-a) before entering the routine.  This maps x from (a, b) to (-1, 1), over which the Chebyshev
	   * polynomials are defined. &lt;p&gt; If the coefficients are for the inverted interval, in which (a, b) is mapped to (1/b,
	   * 1/a), the transformation required is x -&gt; 2(2ab/x - b - a)/(b-a).  If b is infinity, this becomes x -&gt; 4a/x - 1.
	   * &lt;p&gt; SPEED: &lt;p&gt; Taking advantage of the recurrence properties of the Chebyshev polynomials, the routine requires one
	   * more addition per loop than evaluating a nested polynomial of the same degree.
	   *
	   * @param x    argument to the polynomial.
	   * @param coef the coefficients of the polynomial.
	   * @param N    the number of coefficients.
	   */
	  /*
	  public static double chbevl(double x, double[] coef, int N) {

	    int p = 0;

	    double b0 = coef[p++];
	    double b1 = 0.0;
	    int i = N - 1;

	    double b2;
	    do {
	      b2 = b1;
	      b1 = b0;
	      b0 = x * b1 - b2 + coef[p++];
	    } while (--i &gt; 0);

	    return 0.5 * (b0 - b2);
	  }
	  */
	  /**
	   * Evaluates the given polynomial of degree &lt;tt&gt;N&lt;/tt&gt; at &lt;tt&gt;x&lt;/tt&gt;, assuming coefficient of N is 1.0. Otherwise same
	   * as &lt;tt&gt;polevl()&lt;/tt&gt;.
	   * &lt;pre&gt;
	   *                     2          N
	   * y  =  C  + C x + C x  +...+ C x
	   *        0    1     2          N
	   *
	   * where C  = 1 and hence is omitted from the array.
	   *        N
	   *
	   * Coefficients are stored in reverse order:
	   *
	   * coef[0] = C  , ..., coef[N-1] = C  .
	   *            N-1                   0
	   *
	   * Calling arguments are otherwise the same as polevl().
	   * &lt;/pre&gt;
	   * In the interest of speed, there are no checks for out of bounds arithmetic.
	   *
	   * @param x    argument to the polynomial.
	   * @param coef the coefficients of the polynomial.
	   * @param N    the degree of the polynomial.
	   */
	  /*
	  public static double p1evl(double x, double[] coef, int N) {

	    double ans = x + coef[0];

	    for (int i = 1; i &lt; N; i++) {
	      ans = ans * x + coef[i];
	    }

	    return ans;
	  }
	  */
	  /**
	   * Evaluates the given polynomial of degree &lt;tt&gt;N&lt;/tt&gt; at &lt;tt&gt;x&lt;/tt&gt;.
	   * &lt;pre&gt;
	   *                     2          N
	   * y  =  C  + C x + C x  +...+ C x
	   *        0    1     2          N
	   *
	   * Coefficients are stored in reverse order:
	   *
	   * coef[0] = C  , ..., coef[N] = C  .
	   *            N                   0
	   * &lt;/pre&gt;
	   * In the interest of speed, there are no checks for out of bounds arithmetic.
	   *
	   * @param x    argument to the polynomial.
	   * @param coef the coefficients of the polynomial.
	   * @param N    the degree of the polynomial.
	   */
	  /*
	  public static double polevl(double x, double[] coef, int N) {
	    double ans = coef[0];

	    for (int i = 1; i &lt;= N; i++) {
	      ans = ans * x + coef[i];
	    }

	    return ans;
	  }*/
	  
/*
	  public static double[] givens(double a, double b, double[] csOut) {
		    if (b == 0) {
		      csOut[0] = 1;
		      csOut[1] = 0;
		      return csOut;
		    }
		    if (Math.abs(b) &gt; Math.abs(a)) {
		      double tau = -a / b;
		      csOut[1] = 1 / Math.sqrt(1 + tau * tau);
		      csOut[0] = csOut[1] * tau;
		    } else {
		      double tau = -b / a;
		      csOut[0] = 1 / Math.sqrt(1 + tau * tau);
		      csOut[1] = csOut[0] * tau;
		    }
		    return csOut;
		  }
*/
	  
	  /**
	   * Computes the binomial logistic inverse link function.
	   *
	   * @param r The value to transform.
	   * @return The logit of r.
	   */
/*
	  public static double link(double r) {
	    if (r &lt; 0.0) {
	      double s = Math.exp(r);
	      return s / (1.0 + s);
	    } else {
	      double s = Math.exp(-r);
	      return 1.0 / (1.0 + s);
	    }
	  }
*/
	  
	  /**
	   * Computes the likelihood that a given output sequence was computed by a
	   * given model using the alpha values computed by the forward algorithm.
	   * // TODO I am a bit confused here - where is the output sequence referenced in the comment above in the code?
	   * @param alpha  Matrix of alpha values
	   * @param scaled Set to true if the alpha values are log-scaled.
	   * @return model likelihood.
	   */
	  /*
	  public static double modelLikelihood(Matrix alpha, boolean scaled) {
	    double likelihood = 0;
	    if (scaled) {
	      for (int i = 0; i &lt; alpha.numCols(); ++i) {
	        likelihood += Math.exp(alpha.getQuick(alpha.numRows() - 1, i));
	      }
	    } else {
	      for (int i = 0; i &lt; alpha.numCols(); ++i) {
	        likelihood += alpha.getQuick(alpha.numRows() - 1, i);
	      }
	    }
	    return likelihood;
	  }
	  */
	  
	  /**
	   * Compute the number of trees for a given partition. The first partition (0) may be longer than the rest of
	   * partition because of the remainder.
	   * 
	   * @param numMaps
	   *          total number of maps (partitions)
	   * @param numTrees
	   *          total number of trees to build
	   * @param partition
	   *          partition to compute the number of trees for
	   */
/*
	  public static int nbTrees(int numMaps, int numTrees, int partition) {
	    int nbTrees = numTrees / numMaps;
	    if (partition == 0) {
	      nbTrees += numTrees - nbTrees * numMaps;
	    }
	    
	    return nbTrees;
	  }
*/
	  /*
	  
	  public static void orthonormalizeColumns(Matrix mx) {

		    int n = mx.numCols();

		    for (int c = 0; c &lt; n; c++) {
		      Vector col = mx.viewColumn(c);
		      for (int c1 = 0; c1 &lt; c; c1++) {
		        Vector viewC1 = mx.viewColumn(c1);
		        col.assign(col.minus(viewC1.times(viewC1.dot(col))));

		      }
		      final double norm2 = col.norm(2);
		      col.assign(new DoubleFunction() {
		        @Override
		        public double apply(double x) {
		          return x / norm2;
		        }
		      });
		    }
		  }
		  */
	  
/*
	  public static int stepSize(int recordNumber, double multiplier) {
		    int[] bumps = {1, 2, 5};
		    double log = Math.floor(multiplier * Math.log10(recordNumber));
		    int bump = bumps[(int) log % bumps.length];
		    int scale = (int) Math.pow(10, Math.floor(log / bumps.length));

		    return bump * scale;
		  }
*/
	  /*
	  public static void applyGivensInPlace(double c, double s, double[] row1,
		      double[] row2, int offset, int len) {

		    int n = offset + len;
		    for (int j = offset; j &lt; n; j++) {
		      double tau1 = row1[j];
		      double tau2 = row2[j];
		      row1[j] = c * tau1 - s * tau2;
		      row2[j] = s * tau1 + c * tau2;
		    }
		  }*/
/*
	  public static double choose2(double n) {
		    return n * (n - 1) / 2;
		  }
*/
	  
/*
	  public static double computeWeight(double featureLabelWeight, double labelWeight, double alphaI,
		      double numFeatures) {
		    double numerator = featureLabelWeight + alphaI;
		    double denominator = labelWeight + alphaI * numFeatures;
		    return Math.log(numerator / denominator);
		  }
*/
/*
	  public static double computeWeight(double featureWeight, double featureLabelWeight,
		      double totalWeight, double labelWeight, double alphaI, double numFeatures) {
		    double numerator = featureWeight - featureLabelWeight + alphaI;
		    double denominator = totalWeight - labelWeight + alphaI * numFeatures;
		    return -Math.log(numerator / denominator);
		  }
*/
	  public static double errorRate(double[] labels, double[] predictions) {
		    //Preconditions.checkArgument(labels.length == predictions.length, &quot;labels.length != predictions.length&quot;);
<span class="nc" id="L460">		    double nberrors = 0; // number of instance that got bad predictions</span>
<span class="nc" id="L461">		    double datasize = 0; // number of classified instances</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">		    for (int index = 0; index &lt; labels.length; index++) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">		      if (predictions[index] == -1) {</span>
<span class="nc" id="L465">		        continue; // instance not classified</span>
		      }

<span class="nc bnc" id="L468" title="All 2 branches missed.">		      if (predictions[index] != labels[index]) {</span>
<span class="nc" id="L469">		        nberrors++;</span>
		      }

<span class="nc" id="L472">		      datasize++;</span>
		    }

<span class="nc" id="L475">		    return nberrors / datasize;</span>
		  }

/*
	  public static double[] fromRho(double rho, double[] csOut) {
		    if (rho == 1) {
		      csOut[0] = 0;
		      csOut[1] = 1;
		      return csOut;
		    }
		    if (Math.abs(rho) &lt; 1) {
		      csOut[1] = 2 * rho;
		      csOut[0] = Math.sqrt(1 - csOut[1] * csOut[1]);
		      return csOut;
		    }
		    csOut[0] = 2 / rho;
		    csOut[1] = Math.sqrt(1 - csOut[0] * csOut[0]);
		    return csOut;
		  }
*/

	  


}





	 



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201511160932</span></div></body></html>