<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TestClass.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco_ant</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">TestClass.java</span></div><h1>TestClass.java</h1><pre class="source lang-java linenums">import java.util.Random;
import java.util.Arrays;
import java.util.ArrayList;
import java.lang.Math;
import java.lang.reflect.*;

//import Test.MethodCollection2;
//import Test.MethodsFromApacheMath;
//import Test.MethodsFromColt;
//import Test.MethodsFromMahout;
import org.junit.Test;
import org.junit.Rule;
import org.junit.rules.ErrorCollector;
import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.*;

<span class="nc" id="L17">public class TestClass {</span>

<span class="nc" id="L19">    @Rule</span>
    public ErrorCollector collector = new ErrorCollector();

<span class="nc" id="L22">    public static Random rand = new Random();</span>
<span class="nc" id="L23">    public static int CONSTANT_INT = TestClass.getInt(); //dependent on rand</span>
    public static final int MAX = 100;

    public static void mutConst() {
<span class="nc" id="L27">        CONSTANT_INT = getInt();</span>
<span class="nc" id="L28">    }</span>

/*//////////////////////////////////////////////////////
    ADDITIVE: add a positive constant.
        Expected result: increase or remain constant
*///////////////////////////////////////////////////////

    public static int add(int original) {
<span class="nc" id="L36">        return original + CONSTANT_INT;</span>
    }

    public static double add(double original) {
<span class="nc" id="L40">        return original + ( (double)CONSTANT_INT);</span>
    }

    public static long add(long original) {
<span class="nc" id="L44">        return original + ( (long)CONSTANT_INT);</span>
    }

    public static int[] add(int[] original) {
<span class="nc" id="L48">        int[] additive = new int[original.length];</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L50">            additive[i] = original[i] + CONSTANT_INT;</span>
        }
<span class="nc" id="L52">        return additive;</span>
    }

    public static double[] add(double[] original) {
<span class="nc" id="L56">        double[] additive = new double[original.length];</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L58">            additive[i] = original[i] + ( (double)CONSTANT_INT);</span>
        }
<span class="nc" id="L60">        return additive;</span>
    }

    public static boolean addTest(int orig, int next) {
        //orig = Math.abs(orig);
        //next = Math.abs(orig);
<span class="nc bnc" id="L66" title="All 2 branches missed.">        return orig &lt;= next;</span>
    }

    public static boolean addTest(double orig, double next) {
<span class="nc bnc" id="L70" title="All 4 branches missed.">        return ((Double.compare(orig, next) &lt;= 0) || ((next - orig) &gt; -0.0001));</span>
    }

    public static boolean addTest(int[] orig, int[] next) {
<span class="nc bnc" id="L74" title="All 2 branches missed.">        if (orig.length != next.length) { return false; }</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        for (int i = 0; i &lt; orig.length; i++) {</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            if (!addTest(orig[i], next[i])) {</span>
<span class="nc" id="L77">                return false;</span>
            }
        }
<span class="nc" id="L80">        return true;</span>
    }

    public static boolean addTest(double[] orig, double[] next) {
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (orig.length != next.length) { return false; }</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        for (int i = 0; i &lt; orig.length; i++) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            if (!addTest(orig[i], next[i])) {</span>
<span class="nc" id="L87">                return false;</span>
            }
        }
<span class="nc" id="L90">        return true;</span>
    }


/*//////////////////////////////////////////////////////
    EXCLUSIVE: remove an element
        Expected result: decrease or remain constant
*///////////////////////////////////////////////////////

    public static int[] exc(int[] original) {
<span class="nc" id="L100">        int[] excluded = new int[original.length - 1];</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        for (int i = 0; i &lt; excluded.length; i++) { //output excludes final element</span>
<span class="nc" id="L102">            excluded[i] = original[i];</span>
        }
<span class="nc" id="L104">        return excluded;</span>
    }

    public static double[] exc(double[] original) {
<span class="nc" id="L108">        double[] excluded = new double[original.length - 1];</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        for (int i = 0; i &lt; excluded.length; i++) { //output excludes final element</span>
<span class="nc" id="L110">            excluded[i] = original[i];</span>
        }
<span class="nc" id="L112">        return excluded;</span>
    }

<span class="nc" id="L115">    public static int exc(int original) { return original; }</span>

<span class="nc" id="L117">    public static double exc(double original) { return original; }</span>

    public static boolean excTest(int pre, int post) {
        //pre = Math.abs(pre);
        //post = Math.abs(post);
<span class="nc bnc" id="L122" title="All 2 branches missed.">        return (post &lt;= pre);</span>
    }

    public static boolean excTest(int[] pre, int[] post) {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (pre.length != post.length) { return false; }</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (int i = 0; i &lt; pre.length; i++) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (!excTest(pre[i], post[i])) {</span>
<span class="nc" id="L129">                return false;</span>
            }
        }
<span class="nc" id="L132">        return true;</span>
    }

    public static boolean excTest(double pre, double post) {
<span class="nc bnc" id="L136" title="All 4 branches missed.">        return ( (Double.compare(pre, post) &gt;= 0) || ((pre - post) &gt; -0.0001) );</span>
    }

    public static boolean excTest(double[] pre, double[] post) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (pre.length != post.length) { return false; }</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        for (int i = 0; i &lt; pre.length; i++) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (!excTest(pre[i], post[i])) {</span>
<span class="nc" id="L143">                return false;</span>
            }
        }
<span class="nc" id="L146">        return true;</span>
    }



/*//////////////////////////////////////////////////////
    INCLUSIVE: add a new element
        Expected result: increase or remain constant
*///////////////////////////////////////////////////////

    public static int[] inc(int[] original) {
<span class="nc" id="L157">        int[] included = new int[original.length + 1];</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L159">            included[i] = original[i];</span>
        }
<span class="nc" id="L161">        included[original.length] = getInt(); //new final element</span>
<span class="nc" id="L162">        return included;</span>
    }

    public static double[] inc(double[] original) {
<span class="nc" id="L166">        double[] included = new double[original.length + 1];</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L168">            included[i] = original[i];</span>
        }
<span class="nc" id="L170">        included[original.length] = getDouble(); //new final element</span>
<span class="nc" id="L171">        return included;</span>
    }

<span class="nc" id="L174">    public static int inc(int original) { return original; }</span>

<span class="nc" id="L176">    public static double inc(double original) { return original; }</span>

<span class="nc" id="L178">    public static boolean incTest(int o, int n) { return addTest(o, n); }</span>
<span class="nc" id="L179">    public static boolean incTest(double o, double n) { return addTest(o, n); }</span>
<span class="nc" id="L180">    public static boolean incTest(int[] o, int[] n) { return addTest(o, n); }</span>
<span class="nc" id="L181">    public static boolean incTest(double[] o, double[] n) { return addTest(o, n); }</span>


/*//////////////////////////////////////////////////////
    INVERTIVE: take the inverse of each element
        Expected result: decrease or remain constant
*///////////////////////////////////////////////////////

    public static int[] inv(int[] original) {
<span class="nc" id="L190">        int[] inverse = new int[original.length];</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L192">            inverse[i] = 1 / original[i]; //Integer arithmetic. Problem?</span>
        }
<span class="nc" id="L194">        return inverse;</span>
    }

    public static double[] inv(double[] original) {
<span class="nc" id="L198">        double[] inverse = new double[original.length];</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L200">            inverse[i] = 1.0 / original[i];</span>
        }
<span class="nc" id="L202">        return inverse;</span>
    }

    public static double inv(double original) {
<span class="nc" id="L206">        return 1.0 / original;</span>
    }

    public static int inv(int original) {
<span class="nc" id="L210">        return 1 / original;</span>
    }

<span class="nc" id="L213">    public static boolean invTest(int o, int n) { return excTest(o, n); }</span>
<span class="nc" id="L214">    public static boolean invTest(double o, double n) { return excTest(o, n); }</span>
<span class="nc" id="L215">    public static boolean invTest(int[] o, int[] n) { return excTest(o, n); }</span>
<span class="nc" id="L216">    public static boolean invTest(double[] o, double[] n) { return excTest(o, n); }</span>


/*//////////////////////////////////////////////////////
    MULTIPLICATIVE: multiply by a positive constant
        Expected result: increase or remain constant
*///////////////////////////////////////////////////////

    public static int[] mult(int[] original) {
<span class="nc" id="L225">        int[] multiplied = new int[original.length];</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L227">            multiplied[i] = original[i] * CONSTANT_INT;</span>
        }
<span class="nc" id="L229">        return multiplied;</span>
    }

    public static double[] mult(double[] original) {
<span class="nc" id="L233">        double[] multiplied = new double[original.length];</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        for (int i = 0; i &lt; original.length; i++) {</span>
<span class="nc" id="L235">            multiplied[i] = original[i] * CONSTANT_INT;</span>
        }
<span class="nc" id="L237">        return multiplied;</span>
    }

    public static double mult(double original) {
<span class="nc" id="L241">        return original * (double)CONSTANT_INT;</span>
    }

    public static int mult(int original) {
<span class="nc" id="L245">        return original * CONSTANT_INT;</span>
    }

<span class="nc" id="L248">    public static boolean multTest(int o, int n) { return addTest(o, n); }</span>
<span class="nc" id="L249">    public static boolean multTest(double o, double n) { return addTest(o, n); }</span>
<span class="nc" id="L250">    public static boolean multTest(int[] o, int[] n) { return addTest(o, n); }</span>
<span class="nc" id="L251">    public static boolean multTest(double[] o, double[] n) { return addTest(o, n); }</span>


/*//////////////////////////////////////////////////////
    PERMUTIVE: randomly permute the elements
        Expected result: remain constant
*///////////////////////////////////////////////////////

    public static int[] perm(int[] original) {
        int temp, index;
<span class="nc" id="L261">        int[] permuted = Arrays.copyOf(original, original.length);</span>
<span class="nc" id="L262">        Random r = new Random();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (int i = original.length - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L264">            index = r.nextInt(i+1);</span>
<span class="nc" id="L265">            temp = permuted[i];</span>
<span class="nc" id="L266">            permuted[i] = permuted[index];</span>
<span class="nc" id="L267">            permuted[index] = temp;</span>
        }
<span class="nc" id="L269">        return permuted;</span>
    }

    public static double[] perm(double[] original) {
        int index;
        double temp;
<span class="nc" id="L275">        double[] permuted = Arrays.copyOf(original, original.length);</span>
<span class="nc" id="L276">        Random r = new Random();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        for (int i = original.length - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L278">            index = r.nextInt(i+1);</span>
<span class="nc" id="L279">            temp = permuted[i];</span>
<span class="nc" id="L280">            permuted[i] = permuted[index];</span>
<span class="nc" id="L281">            permuted[index] = temp;</span>
        }
<span class="nc" id="L283">        return permuted;</span>
    }

<span class="nc" id="L286">    public static double perm(double original) { return original; }</span>
<span class="nc" id="L287">    public static int perm(int original) { return original; }</span>

    public static boolean permTest(int o, int n) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        return (o == n);</span>
    }

    public static boolean permTest(double o, double n) {
<span class="nc bnc" id="L294" title="All 4 branches missed.">        return ((Double.compare(o,n) == 0) || (Math.abs(o - n) &lt; 0.0001));</span>
    }

    public static boolean permTest(int[] o, int[] n) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (o.length != n.length) { return false; }</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int i = 0; i &lt; o.length; i++) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (!permTest(o[i], n[i])) {</span>
<span class="nc" id="L301">                return false;</span>
            }
        }
<span class="nc" id="L304">        return true;</span>
    }

    public static boolean permTest(double[] o, double[] n) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (o.length != n.length) { return false; }</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        for (int i = 0; i &lt; o.length; i++) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (!permTest(o[i], n[i])) {</span>
<span class="nc" id="L311">                return false;</span>
            }
        }
<span class="nc" id="L314">        return true;</span>
    }

/*//////////////////////////////////////////////////////////////////////
    testThis(): test the given method on the given 
                metamorphic relation.
        
    @param test      The relationship to test, (&quot;add&quot;, &quot;exc&quot;, etc.)
    @param thisClass The class the test function belongs to, assumed to 
                     be part of the Test package
    @param function  The function name to be tested
    @param args      The arguments to the function

    @return boolean if the relation holds,
            otherwise false
*///////////////////////////////////////////////////////////////////////
    public boolean testThis(String test, String thisClass, String function, Object... args) {

        //System.out.println(&quot;testThis() Entering &lt;&lt;&lt;&lt;&lt;&lt;&quot;);

<span class="nc" id="L334">        boolean passed = false;</span>
        //thisClass = &quot;Test.&quot; + thisClass; //All /src classes are in Test package

        //find the correct function to execute - That long function is going to cause problems
<span class="nc" id="L338">        Class[] argClasses = new Class[args.length];</span>
        Class argClass;
<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (int i = 0; i &lt; argClasses.length; i++) {</span>
<span class="nc" id="L341">            argClass = args[i].getClass();</span>
            //System.out.println(&quot;Class: &quot; + argClass);
            //System.out.println(&quot;Component: &quot; + argClass.getComponentType());
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (argClass == Integer.class) {</span>
<span class="nc" id="L345">                argClasses[i] = int.class;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            } else if (argClass == Double.class) {</span>
<span class="nc" id="L347">                argClasses[i] = double.class;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            } else if (argClass.getComponentType() == int.class) {</span>
<span class="nc" id="L349">                argClasses[i] = int[].class;</span>
<span class="nc" id="L350">                args[i] = Arrays.copyOf((int[])args[i], ((int[])args[i]).length);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            } else if (argClass.getComponentType() == double.class) {</span>
<span class="nc" id="L352">                argClasses[i] = double[].class;</span>
<span class="nc" id="L353">                args[i] = Arrays.copyOf((double[])args[i], ((double[])args[i]).length);</span>
            } else {
<span class="nc" id="L355">                System.out.println(&quot;PROBLEM - NO CLASS ASSIGNED&quot;);</span>
            }
                
        }

        //Get the method being tested
        try {
<span class="nc" id="L362">            Class&lt;?&gt; clazz = Class.forName(thisClass);</span>
            //All constructors should be default
<span class="nc" id="L364">            Constructor&lt;?&gt; construct = clazz.getConstructor();</span>
<span class="nc" id="L365">            Object inst = construct.newInstance();</span>

<span class="nc" id="L367">            Method func = clazz.getMethod(function, argClasses);</span>

                //Get the test support functions
<span class="nc" id="L370">                Class type = null;</span>
                try {
                    //takes arg classes as input - THERE MAY BE MORE THAN ONE PERMUTE FUNCTION PER TEST
<span class="nc" id="L373">                    Method[] permuteFuncs = new Method[argClasses.length];</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    for (int j = 0; j &lt; argClasses.length; j++) {</span>
<span class="nc" id="L375">                        permuteFuncs[j] = TestClass.class.getMethod(test, argClasses[j]); </span>
                    }
                    //takes return types as input and all have two matching args
<span class="nc" id="L378">                    type = func.getReturnType();</span>
<span class="nc" id="L379">                    Method MRTestFunc = TestClass.class.getMethod(test + &quot;Test&quot;, type, type);</span>

                    /*
                    try {
                        System.out.println(&quot;Original Inputs:&quot;);
                        for (Object in: args) {
                            System.out.println(Arrays.toString((int[])in));
                        }
                    } catch (Exception e) {
                        System.out.println(&quot;not an array&quot;);
                    }
                    */

                    //get original return value
<span class="nc" id="L393">                    Object return1 = func.invoke(inst, args);</span>

                    //System.out.println(&quot;Original Output: &quot; + return1);

                    //modify arguments
<span class="nc" id="L398">                    Object[] permutedArgs = new Object[args.length];</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                    for (int j = 0; j &lt; args.length; j++) {</span>
<span class="nc" id="L400">                        permutedArgs[j] = permuteFuncs[j].invoke(null, args[j]);</span>
                    }

                    /*
                    try {
                        System.out.println(&quot;Modified Inputs:&quot;);
                        for (Object in: permutedArgs) {
                            System.out.println(Arrays.toString((int[])in));
                        }
                    } catch (Exception e) {
                        System.out.println(&quot;not an array&quot;);
                    }
                    */
        
                    //get modified return value
<span class="nc" id="L415">                    Object return2 = func.invoke(inst, permutedArgs);</span>

                    //System.out.println(&quot;Modified Output: &quot; + return2);

                    //System.out.println (&quot;Running test: &quot; + MRTestFunc);

                    //run test
<span class="nc bnc" id="L422" title="All 2 branches missed.">                    if ((boolean)MRTestFunc.invoke(null, return1, return2)) {</span>
<span class="nc" id="L423">                        passed = true;</span>
                    }
<span class="nc" id="L425">                } catch(NoSuchMethodException e) {</span>
<span class="nc" id="L426">                    System.out.println(&quot;TESTTHIS EXCEPTION: NO SUCH METHOD: &quot;+ test + &quot;Test(&quot; + type + &quot;,&quot; + type + &quot;)&quot;);</span>
<span class="nc" id="L427">                    e.printStackTrace();</span>
<span class="nc" id="L428">                }</span>

<span class="nc" id="L430">        } catch(Exception e) {</span>
            //report exceptions seperately
<span class="nc" id="L432">            System.out.print(&quot;&amp;exception.&quot; + function + &quot;.&quot; + test);</span>
<span class="nc" id="L433">            e.printStackTrace();</span>
<span class="nc" id="L434">        }</span>

        //System.out.println(&quot;testThis() Exiting with &quot; + passed);
<span class="nc" id="L437">        return passed;</span>
    }


/*//////////////////////////////////////////////////////
    Random retreival methods
        - Get input values for test instances
*///////////////////////////////////////////////////////

    public static int getInt() {
<span class="nc" id="L447">        return rand.nextInt(MAX) + 1;</span>
    }

    public static int getInt(int max) {
<span class="nc" id="L451">        return rand.nextInt(max) + 1;</span>
    }

    public static int[] getIntArray() {
<span class="nc" id="L455">        int size = rand.nextInt(8) + 2;</span>
<span class="nc" id="L456">        return getIntArray(size);</span>
    }

    public static int[] getIntArray(int size) {
<span class="nc" id="L460">        int[] arr = new int[size];</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L462">            arr[i] = rand.nextInt(MAX) + 1;</span>
        }
<span class="nc" id="L464">        return arr;</span>
    }

    public static double getDouble() {
<span class="nc" id="L468">        return rand.nextDouble() * getInt() + 1;</span>
    }

    public static double getNextDouble() {
<span class="nc" id="L472">        return rand.nextDouble();</span>
    }

    public static double[] getDoubleArray() {
<span class="nc" id="L476">        int size = rand.nextInt(9) + 1;</span>
<span class="nc" id="L477">        double[] arr = new double[size];</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L479">            arr[i] = (rand.nextDouble() * MAX) + 1;</span>
        }
<span class="nc" id="L481">        return arr;</span>
    }

    public static double[] getDoubleArray(int size) {
<span class="nc" id="L485">        double[] arr = new double[size];</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L487">            arr[i] = (rand.nextDouble() * MAX) + 1;</span>
        }
<span class="nc" id="L489">        return arr;</span>
    }

    public static long getLong() {
<span class="nc" id="L493">        return Math.abs(rand.nextLong());</span>
    }

    public static Boolean getBoolean() {
<span class="nc" id="L497">        return rand.nextBoolean();</span>
    }

    public long[][] get2DLongArray() {
<span class="nc" id="L501">        int size1 = rand.nextInt(MAX) + 1;</span>
<span class="nc" id="L502">        int size2 = rand.nextInt(MAX) + 1;</span>
<span class="nc" id="L503">        long[][] arr = new long[size1][size2];</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        for (int i = 0; i &lt; size1; i++) {</span>
<span class="nc" id="L505">            arr[i] = new long[size2];</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            for (int j = 0; j &lt; size2; j++) {</span>
<span class="nc" id="L507">                arr[i][j] = rand.nextLong();</span>
            }
        }
<span class="nc" id="L510">        return arr;</span>
    }


    public static void main(String[] args) {

<span class="nc" id="L516">        TestClass tester = new TestClass();</span>

        //System.out.println(&quot;TEST: add_values&quot;);
<span class="nc" id="L519">        int[] orig = getIntArray();</span>
        //int r1 = MethodCollection2.add_values(orig);

        //String fail = &quot;&quot;;
        //tester.collector.checkThat(fail += &quot;add&amp;&quot;, tester.testThis(&quot;add&quot;, &quot;MethodCollection2&quot;, &quot;add_values&quot;, orig), equalTo(true));
        //tester.collector.checkThat(fail += &quot;mult&amp;&quot;, tester.testThis(&quot;mult&quot;, &quot;MethodCollection2&quot;, &quot;add_values&quot;, orig), equalTo(true));
        //tester.collector.checkThat(fail += &quot;exc&amp;&quot;, tester.testThis(&quot;exc&quot;, &quot;MethodCollection2&quot;, &quot;add_values&quot;, orig), equalTo(true));
        //tester.collector.checkThat(fail += &quot;inc&amp;&quot;, tester.testThis(&quot;inc&quot;, &quot;MethodCollection2&quot;, &quot;add_values&quot;, orig), equalTo(true));
        //tester.collector.checkThat(fail += &quot;perm&amp;&quot;, tester.testThis(&quot;perm&quot;, &quot;MethodCollection2&quot;, &quot;add_values&quot;, orig), equalTo(true));
        //tester.collector.checkThat(fail += &quot;inv&amp;&quot;, tester.testThis(&quot;inv&quot;, &quot;MethodCollection2&quot;, &quot;add_values&quot;, orig), equalTo(true));
<span class="nc" id="L529">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201511160932</span></div></body></html>